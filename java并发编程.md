>#Java并发编程的艺术总结

##第一章
####测量上下文切换次数和时长：

    .使用Lmbench可以测试上下文（线程，进程）切换的时长。
    .使用vmstat测量上下文（线程，进程）切换的次数，例在Linux下执行：vmstat -d 1。

####如何减少上下文切换：

    .无锁并发编程。
    .CAS(比较与交换，Compare and swap）)算法（例如Atomic包就使用了CAS算法实现数据更新，不需要加锁）。
    .使用最少线程和协程（在单线程实现多任务的调度）。

####Java中的原子操作包括：

    1）除long和double之外的基本类型的赋值操作
    2）所有引用（reference）的赋值操作
    3）java.concurrent.Atomic.* 包中所有类的一切操作（java在jdk1.5开始提供该包）。
<font color="0000FF">
疑惑:为什么java对long和double的赋值操作是非原子操作！
</font>

    long和double占用的字节数都是8，也就是64bits。在32位操作系统上对64位的数据的读写要分两步完成，每一步取32位数据。这样对
	double和long的赋值操作就会有问题：如果有两个线程同时写一个变量内存，一个进程写低32位，而另一个写高32位，
	这样将导致获取的64位数据是失效的数据。因此需要使用volatile关键字来防止此类现象。volatile本身不保证获取和设置操作的原子性，
	仅仅保持修改的可见性。但是java的内存模型保证声明为volatile的long和double变量的get和set操作是原子的，同时目前的商用java虚拟机几乎都把64位的数据的读写操作作为原子操作来对待，因此在编写代码时一般不需要把long和double变量专门声明为volatile。


